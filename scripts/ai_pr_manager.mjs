#!/usr/bin/env node

/**
 * AI PR Manager
 * Handles branch creation, commits, and PR management for the E2E self-healing system
 */

import { execSync, spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const WORKSPACE_ROOT = path.resolve(__dirname, '..');

// Configuration
const CONFIG = {
  commitAuthor: {
    name: 'ai-bot',
    email: 'ai-bot@users.noreply.github.com',
  },
  branchPrefix: 'ai-auto-fixes',
  prTitlePrefix: 'ðŸ¤– Auto-Healed',
};

/**
 * Initialize the PR manager
 */
async function initialize() {
  console.log('ðŸ”§ Initializing AI PR Manager...');

  try {
    // Check if git is available
    try {
      execSync('git --version', { cwd: WORKSPACE_ROOT });
    } catch (e) {
      throw new Error('Git is not available');
    }

    // Check if we're in a git repository
    try {
      execSync('git rev-parse --git-dir', { cwd: WORKSPACE_ROOT });
    } catch (e) {
      throw new Error('Not in a git repository');
    }

    console.log('âœ… PR Manager initialized');
    return true;
  } catch (error) {
    console.error('âŒ PR Manager initialization failed:', error);
    return false;
  }
}

/**
 * Create branch and commit changes
 */
async function createBranchAndCommit(runId, changes, fixes, testResults) {
  console.log(`ðŸŒ¿ Creating branch and committing changes for run ${runId}...`);

  try {
    const branchName = `${CONFIG.branchPrefix}/${runId}`;

    // Create and checkout branch
    await createBranch(branchName);

    // Stage changes
    await stageChanges();

    // Create commit
    await createCommit(runId, changes, fixes, testResults);

    // Push branch
    await pushBranch(branchName);

    console.log(`âœ… Branch ${branchName} created and pushed`);
    return branchName;
  } catch (error) {
    console.error('âŒ Branch creation failed:', error);
    return null;
  }
}

/**
 * Create a new branch
 */
async function createBranch(branchName) {
  try {
    // Check if branch already exists
    try {
      execSync(`git show-ref --verify --quiet refs/heads/${branchName}`, {
        cwd: WORKSPACE_ROOT,
      });
      console.log(`âš ï¸ Branch ${branchName} already exists, switching to it`);
      execSync(`git checkout ${branchName}`, { cwd: WORKSPACE_ROOT });
    } catch (e) {
      // Branch doesn't exist, create it
      execSync(`git checkout -b ${branchName}`, { cwd: WORKSPACE_ROOT });
      console.log(`âœ… Branch ${branchName} created`);
    }
  } catch (error) {
    throw new Error(`Failed to create branch: ${error.message}`);
  }
}

/**
 * Stage changes
 */
async function stageChanges() {
  try {
    // Add all changes
    execSync('git add .', { cwd: WORKSPACE_ROOT });

    // Check if there are changes to commit
    const status = execSync('git status --porcelain', {
      cwd: WORKSPACE_ROOT,
      encoding: 'utf8',
    });

    if (!status.trim()) {
      console.log('âš ï¸ No changes to commit');
      return false;
    }

    console.log('âœ… Changes staged');
    return true;
  } catch (error) {
    throw new Error(`Failed to stage changes: ${error.message}`);
  }
}

/**
 * Create commit
 */
async function createCommit(runId, changes, fixes, testResults) {
  try {
    const commitMessage = generateCommitMessage(
      runId,
      changes,
      fixes,
      testResults
    );

    execSync(`git commit -m "${commitMessage}"`, {
      cwd: WORKSPACE_ROOT,
      env: {
        ...process.env,
        GIT_AUTHOR_NAME: CONFIG.commitAuthor.name,
        GIT_AUTHOR_EMAIL: CONFIG.commitAuthor.email,
        GIT_COMMITTER_NAME: CONFIG.commitAuthor.name,
        GIT_COMMITTER_EMAIL: CONFIG.commitAuthor.email,
      },
    });

    console.log('âœ… Commit created');
    return true;
  } catch (error) {
    throw new Error(`Failed to create commit: ${error.message}`);
  }
}

/**
 * Generate commit message
 */
function generateCommitMessage(runId, changes, fixes, testResults) {
  const passedTests = testResults.filter(t => t.status === 'passed').length;
  const failedTests = testResults.filter(t => t.status === 'failed').length;
  const fixedTests = fixes.filter(f => f.success !== false).length;

  return `${CONFIG.prTitlePrefix}: ${runId}

## Summary
- Fixed ${fixedTests} tests
- Resolved ${changes.errors || 0} errors
- Addressed ${changes.warnings || 0} warnings
- Applied ${fixes.length} automated fixes

## Test Results
- Total Tests: ${testResults.length}
- Passed: ${passedTests}
- Failed: ${failedTests}

## Changes Made
${changes.summary || 'Various automated fixes and improvements'}

## Fixes Applied
${fixes.map(fix => `- ${fix.type}: ${fix.description}`).join('\n')}

Generated by Ultimate E2E Self-Healing Runner
Run ID: ${runId}
Timestamp: ${new Date().toISOString()}`;
}

/**
 * Push branch
 */
async function pushBranch(branchName) {
  try {
    execSync(`git push origin ${branchName}`, { cwd: WORKSPACE_ROOT });
    console.log(`âœ… Branch ${branchName} pushed`);
    return true;
  } catch (error) {
    throw new Error(`Failed to push branch: ${error.message}`);
  }
}

/**
 * Create pull request
 */
async function createPullRequest(
  runId,
  branchName,
  changes,
  fixes,
  testResults
) {
  console.log(`ðŸ“ Creating pull request for ${branchName}...`);

  try {
    const prTitle = `${CONFIG.prTitlePrefix}: ${runId}`;
    const prBody = generatePRBody(runId, changes, fixes, testResults);

    // Check if GitHub CLI is available
    try {
      execSync('gh --version', { cwd: WORKSPACE_ROOT });

      // Create PR using GitHub CLI
      const prUrl = await createPRWithGitHubCLI(prTitle, prBody, branchName);

      if (prUrl) {
        console.log(`âœ… Pull request created: ${prUrl}`);
        return prUrl;
      }
    } catch (e) {
      console.log('âš ï¸ GitHub CLI not available, creating PR manually');
    }

    // Fallback: provide instructions for manual PR creation
    const prInstructions = generatePRInstructions(
      runId,
      branchName,
      prTitle,
      prBody
    );
    await savePRInstructions(prInstructions);

    console.log('âœ… PR instructions saved');
    return prInstructions;
  } catch (error) {
    console.error('âŒ PR creation failed:', error);
    return null;
  }
}

/**
 * Create PR using GitHub CLI
 */
async function createPRWithGitHubCLI(title, body, branchName) {
  try {
    const result = execSync(
      `gh pr create --title "${title}" --body "${body}" --head ${branchName}`,
      {
        cwd: WORKSPACE_ROOT,
        encoding: 'utf8',
      }
    );

    // Extract PR URL from output
    const urlMatch = result.match(/https:\/\/github\.com\/[^\s]+/);
    return urlMatch ? urlMatch[0] : result.trim();
  } catch (error) {
    console.log('âš ï¸ GitHub CLI PR creation failed:', error.message);
    return null;
  }
}

/**
 * Generate PR body
 */
function generatePRBody(runId, changes, fixes, testResults) {
  const passedTests = testResults.filter(t => t.status === 'passed').length;
  const failedTests = testResults.filter(t => t.status === 'failed').length;
  const fixedTests = fixes.filter(f => f.success !== false).length;

  return `## ðŸ¤– Automated E2E Self-Healing Report

### Run Information
- **Run ID**: ${runId}
- **Timestamp**: ${new Date().toISOString()}
- **Branch**: ${CONFIG.branchPrefix}/${runId}

### Summary
- âœ… **Fixed Tests**: ${fixedTests}
- âŒ **Errors Resolved**: ${changes.errors || 0}
- âš ï¸ **Warnings Addressed**: ${changes.warnings || 0}
- ðŸ”§ **Automated Fixes Applied**: ${fixes.length}

### Test Results
| Metric | Count |
|--------|-------|
| Total Tests | ${testResults.length} |
| Passed | ${passedTests} |
| Failed | ${failedTests} |
| Success Rate | ${testResults.length > 0 ? Math.round((passedTests / testResults.length) * 100) : 0}% |

### Changes Made
${changes.summary || 'Various automated fixes and improvements'}

### Fixes Applied
${fixes.length > 0 ? fixes.map(fix => `- **${fix.type}**: ${fix.description}`).join('\n') : 'No fixes applied'}

### Files Modified
${changes.files ? changes.files.map(file => `- \`${file}\``).join('\n') : 'Various files'}

### Recommendations
${changes.recommendations ? changes.recommendations.map(rec => `- ${rec}`).join('\n') : 'Review the changes and ensure they meet requirements'}

---

**Generated by Ultimate E2E Self-Healing Runner**
- Run ID: ${runId}
- Timestamp: ${new Date().toISOString()}
- System: ${process.platform} ${process.arch}
- Node: ${process.version}`;
}

/**
 * Generate PR instructions
 */
function generatePRInstructions(runId, branchName, title, body) {
  return `# Pull Request Instructions

## Run ID: ${runId}
## Branch: ${branchName}

### Title
${title}

### Body
${body}

### Steps to Create PR
1. Go to your repository on GitHub
2. Click "Compare & pull request" for branch \`${branchName}\`
3. Use the title and body above
4. Review the changes
5. Create the pull request

### Branch Information
- Source Branch: ${branchName}
- Target Branch: main (or your default branch)
- Author: ${CONFIG.commitAuthor.name} <${CONFIG.commitAuthor.email}>

### Files to Review
${changes.files ? changes.files.map(file => `- ${file}`).join('\n') : 'All modified files'}

---
Generated by Ultimate E2E Self-Healing Runner
Run ID: ${runId}
Timestamp: ${new Date().toISOString()}`;
}

/**
 * Save PR instructions
 */
async function savePRInstructions(instructions) {
  const instructionsPath = path.join(
    WORKSPACE_ROOT,
    'reports',
    'pr_instructions.md'
  );
  await fs.writeFile(instructionsPath, instructions);
  console.log(`âœ… PR instructions saved to ${instructionsPath}`);
}

/**
 * Check if PR already exists
 */
async function checkExistingPR(branchName) {
  try {
    const result = execSync(
      `gh pr list --head ${branchName} --json number,title,url`,
      {
        cwd: WORKSPACE_ROOT,
        encoding: 'utf8',
      }
    );

    const prs = JSON.parse(result);
    return prs.length > 0 ? prs[0] : null;
  } catch (error) {
    console.log('âš ï¸ Could not check existing PRs:', error.message);
    return null;
  }
}

/**
 * Update existing PR
 */
async function updateExistingPR(prNumber, runId, changes, fixes, testResults) {
  console.log(`ðŸ“ Updating existing PR #${prNumber}...`);

  try {
    const prBody = generatePRBody(runId, changes, fixes, testResults);

    execSync(`gh pr edit ${prNumber} --body "${prBody}"`, {
      cwd: WORKSPACE_ROOT,
    });

    console.log(`âœ… PR #${prNumber} updated`);
    return true;
  } catch (error) {
    console.log('âš ï¸ PR update failed:', error.message);
    return false;
  }
}

/**
 * Merge PR if all checks pass
 */
async function mergePRIfReady(prNumber) {
  console.log(`ðŸ”„ Checking if PR #${prNumber} is ready to merge...`);

  try {
    // Check PR status
    const result = execSync(`gh pr view ${prNumber} --json statusCheckRollup`, {
      cwd: WORKSPACE_ROOT,
      encoding: 'utf8',
    });

    const pr = JSON.parse(result);
    const checks = pr.statusCheckRollup || [];

    // Check if all checks are passing
    const allPassing = checks.every(check => check.state === 'SUCCESS');

    if (allPassing) {
      console.log('âœ… All checks passing, merging PR...');

      execSync(`gh pr merge ${prNumber} --merge --delete-branch`, {
        cwd: WORKSPACE_ROOT,
      });

      console.log(`âœ… PR #${prNumber} merged successfully`);
      return true;
    } else {
      console.log('âš ï¸ Some checks are still running or failed');
      return false;
    }
  } catch (error) {
    console.log('âš ï¸ PR merge check failed:', error.message);
    return false;
  }
}

/**
 * Clean up old branches
 */
async function cleanupOldBranches() {
  console.log('ðŸ§¹ Cleaning up old branches...');

  try {
    // Get all branches with the prefix
    const result = execSync(
      `git branch -r --list origin/${CONFIG.branchPrefix}/*`,
      {
        cwd: WORKSPACE_ROOT,
        encoding: 'utf8',
      }
    );

    const branches = result
      .trim()
      .split('\n')
      .filter(b => b.trim());

    // Keep only the last 10 branches
    if (branches.length > 10) {
      const branchesToDelete = branches.slice(0, branches.length - 10);

      for (const branch of branchesToDelete) {
        const branchName = branch.replace('origin/', '');
        try {
          execSync(`git push origin --delete ${branchName}`, {
            cwd: WORKSPACE_ROOT,
          });
          console.log(`âœ… Deleted old branch: ${branchName}`);
        } catch (e) {
          console.log(`âš ï¸ Failed to delete branch ${branchName}:`, e.message);
        }
      }
    }

    console.log('âœ… Branch cleanup complete');
  } catch (error) {
    console.log('âš ï¸ Branch cleanup failed:', error.message);
  }
}

/**
 * Get branch status
 */
async function getBranchStatus(branchName) {
  try {
    const result = execSync(`git status --porcelain`, {
      cwd: WORKSPACE_ROOT,
      encoding: 'utf8',
    });

    const changes = result
      .trim()
      .split('\n')
      .filter(line => line.trim());

    return {
      hasChanges: changes.length > 0,
      changes: changes.map(line => ({
        status: line.substring(0, 2),
        file: line.substring(3),
      })),
    };
  } catch (error) {
    console.log('âš ï¸ Failed to get branch status:', error.message);
    return { hasChanges: false, changes: [] };
  }
}

/**
 * Main function to handle the complete PR workflow
 */
async function handlePRWorkflow(runId, changes, fixes, testResults) {
  console.log(`ðŸš€ Starting PR workflow for run ${runId}...`);

  try {
    const initialized = await initialize();
    if (!initialized) {
      throw new Error('PR Manager initialization failed');
    }

    const branchName = `${CONFIG.branchPrefix}/${runId}`;

    // Check if PR already exists
    const existingPR = await checkExistingPR(branchName);

    if (existingPR) {
      console.log(`ðŸ“ PR already exists: ${existingPR.url}`);

      // Update existing PR
      await updateExistingPR(
        existingPR.number,
        runId,
        changes,
        fixes,
        testResults
      );

      // Check if ready to merge
      await mergePRIfReady(existingPR.number);

      return existingPR.url;
    } else {
      // Create new branch and PR
      const createdBranch = await createBranchAndCommit(
        runId,
        changes,
        fixes,
        testResults
      );

      if (createdBranch) {
        const prUrl = await createPullRequest(
          runId,
          createdBranch,
          changes,
          fixes,
          testResults
        );

        // Clean up old branches
        await cleanupOldBranches();

        return prUrl;
      }
    }

    return null;
  } catch (error) {
    console.error('âŒ PR workflow failed:', error);
    return null;
  }
}

// Run the PR manager
if (import.meta.url === `file://${process.argv[1]}`) {
  (async () => {
    const initialized = await initialize();
    if (initialized) {
      // Example usage
      const runId = `run-${Date.now()}`;
      const changes = {
        summary: 'Example changes',
        errors: 0,
        warnings: 0,
        files: ['src/example.ts'],
      };
      const fixes = [
        { type: 'eslint', description: 'Fixed linting issues', success: true },
      ];
      const testResults = [
        { title: 'Example test', status: 'passed', duration: 1000 },
      ];

      await handlePRWorkflow(runId, changes, fixes, testResults);
    }
  })().catch(console.error);
}

export {
  handlePRWorkflow,
  createBranchAndCommit,
  createPullRequest,
  updateExistingPR,
  mergePRIfReady,
  cleanupOldBranches,
};
