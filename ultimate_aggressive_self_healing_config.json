{
  "name": "Ultimate Aggressive Self-Healing & Test Generator",
  "description": "Fully autonomous pipeline: generates â‰¥100 Playwright + Supawright tests per module, executes, self-heals code & DB, repeats until 100% success, then opens PR.",
  "primary_objective": "Ensure all modules pass complete E2E + DB + integration tests with zero errors, zero warnings, and fully functional system ready for production.",
  "stop_condition": "All generated tests pass, DB validated, no runtime errors/warnings, report indicates overallStatus == OK, errors == 0, warnings == 0.",
  "env_required": [
    "NEXT_PUBLIC_SUPABASE_URL",
    "NEXT_PUBLIC_SUPABASE_ANON_KEY",
    "SUPABASE_SERVICE_ROLE_KEY",
    "GITHUB_TOKEN",
    "CURSOR_API_KEY"
  ],
  "safety_rules": {
    "backup_before_modify": true,
    "avoid_changes_outside": [
      "src",
      "migrations",
      "scripts",
      ".github/workflows"
    ],
    "max_retries_per_test": 10,
    "commit_author_name": "ai-bot",
    "commit_author_email": "ai-bot@users.noreply.github.com"
  },
  "high_level_steps": [
    "1) Initialize workspace: ensure dependencies installed, Playwright browsers ready, Supawright ready.",
    "2) Backup src/ + migrations/ to reports/backups/<timestamp>.",
    "3) Detect all modules in src/.",
    "4) For each module:",
    "   a) Generate â‰¥100 tests covering: UI (Playwright), DB/API/business logic (Supawright), edge cases, concurrency, auth, navigation.",
    "   b) Place tests under tests/generated/<module>/. Ensure idempotence and isolation.",
    "   c) Run generated tests.",
    "   d) If any test fails:",
    "       i) Apply local auto-fixes: eslint --fix, prettier.",
    "       ii) Apply safe DB fixes in temporary schema if needed.",
    "       iii) If still failing, ask Cursor LLM to generate unified-diff patches + reversible SQL migrations.",
    "       iv) Apply patch, rerun failing tests, iterate until success or max_retries reached.",
    "5) After all modules pass, run global integration (Playwright full + Supawright full).",
    "6) Produce artifacts: reports/ai_validation_report.json, reports/final_summary.md, reports/execution.log, dashboard/logs.json, ci_memory.sqlite.",
    "7) Create branch ai-auto-fixes/<runId>, commit all fixes and new tests, push, open PR titled 'ðŸ¤– Auto-Healed: <runId>'."
  ],
  "operational_rules": {
    "db_operations": "All SQL migrations must be reversible, tested in sandbox schema. Never alter production schema directly.",
    "parallelism": "Run tests in parallel (up to min(os.cpus()-1, 4)) with per-worker DB schema isolation.",
    "logging": "All logs written to reports/execution.log and stdout between <CURSOR_LLM_PROMPT_START> markers.",
    "audit": "Record all LLM suggestions in reports/llm_prompts/<timestamp>.json including prompt, response, applied_patch."
  },
  "cursor_instructions": {
    "mode": "aggressive-self-heal-test-generation",
    "actions": [
      "Read repo tree, detect modules in src/.",
      "Ensure dependencies installed, Playwright browsers installed.",
      "Run scripts/ai_full_e2e_healer.mjs; emits <CURSOR_LLM_PROMPT_START> when LLM patch needed.",
      "Apply <PATCH> from LLM, rerun affected tests, iterate.",
      "Commit all successful fixes and new tests, open PR."
    ],
    "on_failure": [
      "Retry twice on environment/network failures with exponential backoff.",
      "If module cannot stabilize after max_retries, create PR with full diagnostics but continue other modules."
    ]
  },
  "outputs_required": [
    "reports/ai_validation_report.json",
    "reports/final_summary.md",
    "reports/execution.log",
    "dashboard/logs.json",
    "ci_memory.sqlite",
    "PR link"
  ],
  "metadata": {
    "runId_template": "run-{{timestamp}}-{{random}}",
    "created_by": "user-request",
    "priority": "urgent"
  }
}
